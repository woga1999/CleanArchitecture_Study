# 4장 구조적 프로그래밍

Assign: dain
Date: January 18, 2022
Status: 완료

유명한 다익스트라.. Dijkstra 프로그래머의 이야기부터 시작한다. 👀

1952년 네덜란드 최초의 프로그래머, 프로그래머라는 직업이 없던 시절, 이론 물리학자라고 말해야했던 시절부터 프로그래밍의 원리나 과학을 증명하기 위해 노력한 사람이다.

### 증명

**데이크스트라가 초기에 인식한 문제**

- 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 하지 못한다.
- 프로그램은 너무 많은 세부사항을 담고 있고, 작은 세부사항이라도 간과하면 결국 예상 외의 방식으로 실패하곤 한다.

**수학적인 원리 "증명(proof)"을 적용해 이런 문제를 해결하고자 했다.**

- 수학에서의 유클리드 계층구조를 프로그래머도 사용할 수 있을거라고 믿었다.
- 그의 비전은 공리, 정리, 다름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다.
- 프로그래머는 입증된 구조를 이용, 이들 구조를 코드와 결합, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식을 기대했다.

**증명하기 위해서 단순한 알고리즘에 대해 기본적인 증명을 작성할 수 있는 기법을 고민했다.**

- 이 과정에서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있음을 발견했다.
- 모듈을 분해할 수 없다면, 합리적으로 증명할 때 필수적인 분할 정복 접근법을 사용할 수 없게 된다.
- goto 문장을 사용하더라도, 방해가 되지 않는 경우는 **분기(if/then/else)** 와 **반복(do/while)** 이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.

**단순한 제어 구조는 순차 실행(sequential execution)과 결합했을 때 특별하다는 것을 깨달았다.**

- 뵘과 야코피니는 모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration) 이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 이 발견을 통해 **모듈을 증명 가능하게 하는 제어 구조 == 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합** 임을 보여줬다.
- **> 구조적 프로그래밍의 탄생 !**

**데이크스트라의 증명은 계속되고 유클리드 계층구조를 만들 수 있을 것이라 생각했다..**

- 순차 구문 : 단순한 연거법을 이용해 입력부터 출력까지 순차적으로 추적
- 분기 : 분기를 통한 각 경로를 열거한 후 순차 구문과 같이 추적
- 반복 : 1의 경우가 올바름을 증명하고, N의 경우가 올바르다고 가정한 후 N+1의 경우도 증명하는 귀납법 사용

### 해로운 성명서 / 기능적 분해

- "goto 문의 해로움" 으로 편지를 써서 세 가지 제어 구조에 대한 자신의 의견을 피력했다.
- 이 논쟁이 10년 이상 지속되었지만.. 컴퓨터 언어가 진화하면서 goto 문장은 밀려나고 구조적 프로그래밍이 자리잡게 되었다.
- 구조적 프로그래밍을 통해 **모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해**할 수 있게 되었다.
- 이는 결국 **모듈을 기능적으로 분해할 수 있음**을 뜻한다.

> 거대한 문제 기술서 - > 고수준의 기능들  - > 저수준의 함수들 - > 구조적 프로그래밍의 제어 구조로 표현 가능
> 
- 1970 후반 ~ 1980 년대에 걸쳐 **구조적 분석(structured analysis), 구조적 설계(structured design)** 기법이 인기를 끌었다. 패러다임!!~

### 하지만.. 엄밀한 증명은 없었다.

프로그램 관점에서 정리에 대한 유클리드 계층구조는 만들어지지 않았다.

수학적인 증명만 있는 것이 아닌.. **과학적 방법(scientific method)** 으로 올바른지를 입증할 수 있다.

- **수학 : 증명 가능한 서술이 참임을 입증하는 원리**
- **과학 : 증명 가능한 서술이 거짓임을 입증하는 원리**

데이크스트라는 **"테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"** 고 말한 적이 있다.

즉, 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

**=> 소프트웨어는 수학적인 구조를 다루는 듯 보이지만, 과학과 비슷하다고 볼 수 있다.**

구조적 프로그래밍은 프로그램을 **증명 가능한 세부 기능 집합으로** / **재귀적으로 분해**할 것을 강요한다.

이후 **테스트를 통해** 증명 가능한 세부 기능들이 **거짓인지를 증명하려고 시도한다.**

거짓임을 증명하는 테스트가 실패한다면, 이 기능들은 **목표에 부합할만큼 충분히 참이라고 여겨진다.**

### 결론

구조적 프로그래밍의 가치는 **"반증 가능한 단위를 만들어 낼 수 있는 능력"** 덕분이다.

소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.

소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트가 쉽도록) 만들기 위해 분주히 노력해야 한다.

---

### 📝 마무리

소프트웨어의 동작 과정을 증명하고자 하는 시도들이 놀라웠고, 소프트웨어는 수학이 아닌 과학에 가깝다는 결론이 굉장히 와닿았다.

증명 가능하도록 더 작은 구조로 쪼갠 것이, 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합이라는 것도..

클린 코드에서 읽었던 메소드 작게 쪼개기, 클래스 단일 책임 원칙 등.. 모두 테스트를 위한 것이고, 모두 증명(반증)을 위한 것이다. 🤔